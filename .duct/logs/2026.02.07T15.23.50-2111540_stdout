.pkg: _optional_hooks> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
.pkg: get_requires_for_build_sdist> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
.pkg: build_sdist> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
py310: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/36/annextube-0.2.1.post48+g40f233bdf.tar.gz
py310: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py310/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: cov-7.0.0, timeout-2.4.0, asyncio-1.3.0
asyncio: mode=strict, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 170 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  7%]
tests/integration/test_checkpoint_commits.py FFFFF.                      [ 10%]
tests/integration/test_comprehensive_backup.py ..                        [ 11%]
tests/integration/test_e2e_backup_features.py ..F                        [ 13%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 17%]
tests/integration/test_update_annexed_files.py ..                        [ 18%]
tests/test_component_mode_bug.py ..                                      [ 20%]
tests/test_date_filtering.py .....                                       [ 22%]
tests/test_tsv_refactoring.py .....                                      [ 25%]
tests/unit/test_archive_discovery.py ........................            [ 40%]
tests/unit/test_atomic_file_write.py ..........                          [ 45%]
tests/unit/test_git_annex_metadata.py ......                             [ 49%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 52%]
tests/unit/test_hierarchical_video_paths.py .............                [ 60%]
tests/unit/test_new_video_detection.py ..                                [ 61%]
tests/unit/test_playlist_model.py ...                                    [ 63%]
tests/unit/test_quota_estimator.py .........                             [ 68%]
tests/unit/test_quota_manager.py .....................                   [ 81%]
tests/unit/test_video_model.py ...                                       [ 82%]
tests/unit/test_youtube_api_client.py ...................                [ 94%]
tests/unit/test_youtube_api_quota_handling.py ..........                 [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp_kjd7kz5/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp_kjd7kz5/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzjwhv4nc/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzjwhv4nc/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
______ TestCheckpointCommits.test_checkpoint_creates_intermediate_commits ______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7ff7e7789930>

    def test_checkpoint_creates_intermediate_commits(self):
        """Test that checkpoints create commits at specified intervals."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Configure with small checkpoint interval (every 2 videos)
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service to return 5 videos
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    # Mock video objects
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Run backup
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + checkpoint(2) + checkpoint(4) + final(5)
>           assert len(commits) >= 4, f"Expected at least 4 commits, got {len(commits)}: {commits}"
E           AssertionError: Expected at least 4 commits, got 1: ['init']
E           assert 1 >= 4
E            +  where 1 = len(['init'])

tests/integration/test_checkpoint_commits.py:100: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpnnmzllp4/videos/videos.tsv'
_____ TestCheckpointCommits.test_checkpoint_disabled_creates_single_commit _____

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7ff7e778b850>

    def test_checkpoint_disabled_creates_single_commit(self):
        """Test that disabling checkpoints creates only final commit."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Disable checkpoints
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_enabled=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + final backup (no checkpoints)
            checkpoint_commits = [c for c in commits if "Checkpoint:" in c]
            assert len(checkpoint_commits) == 0, f"Expected 0 checkpoints, got {checkpoint_commits}"
    
            # Should have final backup commit
            backup_commits = [c for c in commits if "Backup channel:" in c]
>           assert len(backup_commits) == 1, f"Expected 1 backup commit, got {backup_commits}"
E           AssertionError: Expected 1 backup commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:154: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpmi_730_c/videos/videos.tsv'
____________ TestCheckpointCommits.test_checkpoint_regenerates_tsvs ____________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7ff7e7789db0>

    def test_checkpoint_regenerates_tsvs(self):
        """Test that checkpoints regenerate TSV files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=4),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 5)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Spy on export.generate_all calls
                        original_generate = archiver.export.generate_all
                        generate_calls = []
    
                        def track_generate():
                            generate_calls.append(_count_metadata_files(repo_path))
                            return original_generate()
    
                        with patch.object(archiver.export, "generate_all", side_effect=track_generate):
                            archiver.backup_channel("test-channel")
    
            # Should have called generate_all at least twice (checkpoints)
>           assert len(generate_calls) >= 2, f"Expected at least 2 TSV generations, got {len(generate_calls)}"
E           AssertionError: Expected at least 2 TSV generations, got 1
E           assert 1 >= 2
E            +  where 1 = len([0])

tests/integration/test_checkpoint_commits.py:199: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpczazrt4i/videos/videos.tsv'
__________ TestCheckpointCommits.test_keyboard_interrupt_auto_commits __________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7ff7e7789600>

    def test_keyboard_interrupt_auto_commits(self):
        """Test that Ctrl+C triggers auto-commit of partial progress."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(
                    checkpoint_interval=10,  # Won't trigger during test
                    auto_commit_on_interrupt=True
                ),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    # Simulate Ctrl+C after processing 3 videos
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        # Should raise KeyboardInterrupt but auto-commit first
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have partial backup commit
            partial_commits = [c for c in commits if "Partial backup (interrupted)" in c]
>           assert len(partial_commits) == 1, f"Expected 1 partial commit, got {partial_commits}"
E           AssertionError: Expected 1 partial commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:257: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
______ TestCheckpointCommits.test_keyboard_interrupt_without_auto_commit _______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7ff7e77884c0>

    def test_keyboard_interrupt_without_auto_commit(self):
        """Test that disabling auto-commit leaves changes uncommitted."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(auto_commit_on_interrupt=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history - should NOT have partial commit
            commits = _get_git_commit_messages(repo_path)
            partial_commits = [c for c in commits if "Partial backup" in c]
            assert len(partial_commits) == 0, f"Expected 0 partial commits, got {partial_commits}"
    
            # But should have uncommitted changes
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
>           assert result.stdout.strip() != "", "Should have uncommitted changes"
E           AssertionError: Should have uncommitted changes
E           assert '' != ''
E            +  where '' = <built-in method strip of str object at 0x7ff7ea01c030>()
E            +    where <built-in method strip of str object at 0x7ff7ea01c030> = ''.strip
E            +      where '' = CompletedProcess(args=['git', 'status', '--porcelain'], returncode=0, stdout='', stderr='').stdout

tests/integration/test_checkpoint_commits.py:317: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7ff7e76adde0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqpqq7d_i', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqpqq7d_i', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzywuimjq', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzywuimjq', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp5w7b9hgf', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp5w7b9hgf', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
=============================== warnings summary ===============================
.tox/py310/lib/python3.10/site-packages/google/api_core/_python_version_support.py:275
  /home/yoh/proj/annextube/.tox/py310/lib/python3.10/site-packages/google/api_core/_python_version_support.py:275: FutureWarning: You are using a Python version (3.10.17) which Google will stop supporting in new releases of google.api_core once it reaches its end of life (2026-10-04). Please upgrade to the latest Python version, or at least Python 3.11, to continue receiving updates for google.api_core past that date.
    warnings.warn(message, FutureWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_creates_intermediate_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_disabled_creates_single_commit
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_regenerates_tsvs
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_auto_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_without_auto_commit
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
======= 10 failed, 158 passed, 2 skipped, 1 warning in 91.09s (0:01:31) ========
py310: exit 1 (91.78 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2112601
py310: FAIL âœ– in 2 minutes 0.45 seconds
py311: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/37/annextube-0.2.1.post48+g40f233bdf.tar.gz
py311: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.11.12, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py311/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: timeout-2.4.0, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 170 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  7%]
tests/integration/test_checkpoint_commits.py FFFFF.                      [ 10%]
tests/integration/test_comprehensive_backup.py ..                        [ 11%]
tests/integration/test_e2e_backup_features.py ..F                        [ 13%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 17%]
tests/integration/test_update_annexed_files.py ..                        [ 18%]
tests/test_component_mode_bug.py ..                                      [ 20%]
tests/test_date_filtering.py .....                                       [ 22%]
tests/test_tsv_refactoring.py .....                                      [ 25%]
tests/unit/test_archive_discovery.py ........................            [ 40%]
tests/unit/test_atomic_file_write.py ..........                          [ 45%]
tests/unit/test_git_annex_metadata.py ......                             [ 49%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 52%]
tests/unit/test_hierarchical_video_paths.py .............                [ 60%]
tests/unit/test_new_video_detection.py ..                                [ 61%]
tests/unit/test_playlist_model.py ...                                    [ 63%]
tests/unit/test_quota_estimator.py .........                             [ 68%]
tests/unit/test_quota_manager.py .....................                   [ 81%]
tests/unit/test_video_model.py ...                                       [ 82%]
tests/unit/test_youtube_api_client.py ...................                [ 94%]
tests/unit/test_youtube_api_quota_handling.py ..........                 [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp0zxxp_ll/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp0zxxp_ll/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpanafvlb2/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpanafvlb2/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
______ TestCheckpointCommits.test_checkpoint_creates_intermediate_commits ______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f8063fc0c90>

    def test_checkpoint_creates_intermediate_commits(self):
        """Test that checkpoints create commits at specified intervals."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Configure with small checkpoint interval (every 2 videos)
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service to return 5 videos
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    # Mock video objects
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Run backup
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + checkpoint(2) + checkpoint(4) + final(5)
>           assert len(commits) >= 4, f"Expected at least 4 commits, got {len(commits)}: {commits}"
E           AssertionError: Expected at least 4 commits, got 1: ['init']
E           assert 1 >= 4
E            +  where 1 = len(['init'])

tests/integration/test_checkpoint_commits.py:100: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpuyxobohp/videos/videos.tsv'
_____ TestCheckpointCommits.test_checkpoint_disabled_creates_single_commit _____

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f8063fc1790>

    def test_checkpoint_disabled_creates_single_commit(self):
        """Test that disabling checkpoints creates only final commit."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Disable checkpoints
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_enabled=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + final backup (no checkpoints)
            checkpoint_commits = [c for c in commits if "Checkpoint:" in c]
            assert len(checkpoint_commits) == 0, f"Expected 0 checkpoints, got {checkpoint_commits}"
    
            # Should have final backup commit
            backup_commits = [c for c in commits if "Backup channel:" in c]
>           assert len(backup_commits) == 1, f"Expected 1 backup commit, got {backup_commits}"
E           AssertionError: Expected 1 backup commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:154: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmps400t7n8/videos/videos.tsv'
____________ TestCheckpointCommits.test_checkpoint_regenerates_tsvs ____________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f8063f28790>

    def test_checkpoint_regenerates_tsvs(self):
        """Test that checkpoints regenerate TSV files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=4),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 5)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Spy on export.generate_all calls
                        original_generate = archiver.export.generate_all
                        generate_calls = []
    
                        def track_generate():
                            generate_calls.append(_count_metadata_files(repo_path))
                            return original_generate()
    
                        with patch.object(archiver.export, "generate_all", side_effect=track_generate):
                            archiver.backup_channel("test-channel")
    
            # Should have called generate_all at least twice (checkpoints)
>           assert len(generate_calls) >= 2, f"Expected at least 2 TSV generations, got {len(generate_calls)}"
E           AssertionError: Expected at least 2 TSV generations, got 1
E           assert 1 >= 2
E            +  where 1 = len([0])

tests/integration/test_checkpoint_commits.py:199: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpd8yp1bug/videos/videos.tsv'
__________ TestCheckpointCommits.test_keyboard_interrupt_auto_commits __________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f8063f29590>

    def test_keyboard_interrupt_auto_commits(self):
        """Test that Ctrl+C triggers auto-commit of partial progress."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(
                    checkpoint_interval=10,  # Won't trigger during test
                    auto_commit_on_interrupt=True
                ),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    # Simulate Ctrl+C after processing 3 videos
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        # Should raise KeyboardInterrupt but auto-commit first
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have partial backup commit
            partial_commits = [c for c in commits if "Partial backup (interrupted)" in c]
>           assert len(partial_commits) == 1, f"Expected 1 partial commit, got {partial_commits}"
E           AssertionError: Expected 1 partial commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:257: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
______ TestCheckpointCommits.test_keyboard_interrupt_without_auto_commit _______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f8063fc08d0>

    def test_keyboard_interrupt_without_auto_commit(self):
        """Test that disabling auto-commit leaves changes uncommitted."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(auto_commit_on_interrupt=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history - should NOT have partial commit
            commits = _get_git_commit_messages(repo_path)
            partial_commits = [c for c in commits if "Partial backup" in c]
            assert len(partial_commits) == 0, f"Expected 0 partial commits, got {partial_commits}"
    
            # But should have uncommitted changes
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
>           assert result.stdout.strip() != "", "Should have uncommitted changes"
E           AssertionError: Should have uncommitted changes
E           assert '' != ''
E            +  where '' = <built-in method strip of str object at 0x7f80682c5f10>()
E            +    where <built-in method strip of str object at 0x7f80682c5f10> = ''.strip
E            +      where '' = CompletedProcess(args=['git', 'status', '--porcelain'], returncode=0, stdout='', stderr='').stdout

tests/integration/test_checkpoint_commits.py:317: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7f8063f9c410>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpc9kaptba', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpc9kaptba', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpaqpmrkz4', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpaqpmrkz4', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpph9hd25a', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpph9hd25a', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_creates_intermediate_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_disabled_creates_single_commit
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_regenerates_tsvs
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_auto_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_without_auto_commit
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 10 failed, 158 passed, 2 skipped in 87.29s (0:01:27) =============
py311: exit 1 (87.86 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2123951
py311: FAIL âœ– in 1 minute 36.92 seconds
py312: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/38/annextube-0.2.1.post48+g40f233bdf.tar.gz
py312: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.12.12, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py312/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: asyncio-1.3.0, timeout-2.4.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 170 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  7%]
tests/integration/test_checkpoint_commits.py FFFFF.                      [ 10%]
tests/integration/test_comprehensive_backup.py ..                        [ 11%]
tests/integration/test_e2e_backup_features.py ..F                        [ 13%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 17%]
tests/integration/test_update_annexed_files.py ..                        [ 18%]
tests/test_component_mode_bug.py ..                                      [ 20%]
tests/test_date_filtering.py .....                                       [ 22%]
tests/test_tsv_refactoring.py .....                                      [ 25%]
tests/unit/test_archive_discovery.py ........................            [ 40%]
tests/unit/test_atomic_file_write.py ..........                          [ 45%]
tests/unit/test_git_annex_metadata.py ......                             [ 49%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 52%]
tests/unit/test_hierarchical_video_paths.py .............                [ 60%]
tests/unit/test_new_video_detection.py ..                                [ 61%]
tests/unit/test_playlist_model.py ...                                    [ 63%]
tests/unit/test_quota_estimator.py .........                             [ 68%]
tests/unit/test_quota_manager.py .....................                   [ 81%]
tests/unit/test_video_model.py ...                                       [ 82%]
tests/unit/test_youtube_api_client.py ...................                [ 94%]
tests/unit/test_youtube_api_quota_handling.py ..........                 [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp9ujt19r5/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp9ujt19r5/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpe7dqghns/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpe7dqghns/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
______ TestCheckpointCommits.test_checkpoint_creates_intermediate_commits ______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7fcc0f70f980>

    def test_checkpoint_creates_intermediate_commits(self):
        """Test that checkpoints create commits at specified intervals."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Configure with small checkpoint interval (every 2 videos)
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service to return 5 videos
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    # Mock video objects
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Run backup
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + checkpoint(2) + checkpoint(4) + final(5)
>           assert len(commits) >= 4, f"Expected at least 4 commits, got {len(commits)}: {commits}"
E           AssertionError: Expected at least 4 commits, got 1: ['init']
E           assert 1 >= 4
E            +  where 1 = len(['init'])

tests/integration/test_checkpoint_commits.py:100: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpyb_cnfyx/videos/videos.tsv'
_____ TestCheckpointCommits.test_checkpoint_disabled_creates_single_commit _____

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7fcc0f790080>

    def test_checkpoint_disabled_creates_single_commit(self):
        """Test that disabling checkpoints creates only final commit."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Disable checkpoints
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_enabled=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + final backup (no checkpoints)
            checkpoint_commits = [c for c in commits if "Checkpoint:" in c]
            assert len(checkpoint_commits) == 0, f"Expected 0 checkpoints, got {checkpoint_commits}"
    
            # Should have final backup commit
            backup_commits = [c for c in commits if "Backup channel:" in c]
>           assert len(backup_commits) == 1, f"Expected 1 backup commit, got {backup_commits}"
E           AssertionError: Expected 1 backup commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:154: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpdp0ho2su/videos/videos.tsv'
____________ TestCheckpointCommits.test_checkpoint_regenerates_tsvs ____________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7fcc0f7903e0>

    def test_checkpoint_regenerates_tsvs(self):
        """Test that checkpoints regenerate TSV files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=4),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 5)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Spy on export.generate_all calls
                        original_generate = archiver.export.generate_all
                        generate_calls = []
    
                        def track_generate():
                            generate_calls.append(_count_metadata_files(repo_path))
                            return original_generate()
    
                        with patch.object(archiver.export, "generate_all", side_effect=track_generate):
                            archiver.backup_channel("test-channel")
    
            # Should have called generate_all at least twice (checkpoints)
>           assert len(generate_calls) >= 2, f"Expected at least 2 TSV generations, got {len(generate_calls)}"
E           AssertionError: Expected at least 2 TSV generations, got 1
E           assert 1 >= 2
E            +  where 1 = len([0])

tests/integration/test_checkpoint_commits.py:199: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpuf_io1oi/videos/videos.tsv'
__________ TestCheckpointCommits.test_keyboard_interrupt_auto_commits __________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7fcc0f7906e0>

    def test_keyboard_interrupt_auto_commits(self):
        """Test that Ctrl+C triggers auto-commit of partial progress."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(
                    checkpoint_interval=10,  # Won't trigger during test
                    auto_commit_on_interrupt=True
                ),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    # Simulate Ctrl+C after processing 3 videos
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        # Should raise KeyboardInterrupt but auto-commit first
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have partial backup commit
            partial_commits = [c for c in commits if "Partial backup (interrupted)" in c]
>           assert len(partial_commits) == 1, f"Expected 1 partial commit, got {partial_commits}"
E           AssertionError: Expected 1 partial commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:257: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
______ TestCheckpointCommits.test_keyboard_interrupt_without_auto_commit _______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7fcc0f790a40>

    def test_keyboard_interrupt_without_auto_commit(self):
        """Test that disabling auto-commit leaves changes uncommitted."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(auto_commit_on_interrupt=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history - should NOT have partial commit
            commits = _get_git_commit_messages(repo_path)
            partial_commits = [c for c in commits if "Partial backup" in c]
            assert len(partial_commits) == 0, f"Expected 0 partial commits, got {partial_commits}"
    
            # But should have uncommitted changes
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
>           assert result.stdout.strip() != "", "Should have uncommitted changes"
E           AssertionError: Should have uncommitted changes
E           assert '' != ''
E            +  where '' = <built-in method strip of str object at 0x150e958>()
E            +    where <built-in method strip of str object at 0x150e958> = ''.strip
E            +      where '' = CompletedProcess(args=['git', 'status', '--porcelain'], returncode=0, stdout='', stderr='').stdout

tests/integration/test_checkpoint_commits.py:317: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7fcc0f790dd0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpah8j4v7f', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpah8j4v7f', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp2kr3y9m9', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp2kr3y9m9', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp5c83j2mu', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp5c83j2mu', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_creates_intermediate_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_disabled_creates_single_commit
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_regenerates_tsvs
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_auto_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_without_auto_commit
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 10 failed, 158 passed, 2 skipped in 90.87s (0:01:30) =============
py312: exit 1 (91.47 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2135079
py312: FAIL âœ– in 1 minute 41.05 seconds
py313: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/39/annextube-0.2.1.post48+g40f233bdf.tar.gz
py313: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.13.11, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py313/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: cov-7.0.0, asyncio-1.3.0, timeout-2.4.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 170 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  7%]
tests/integration/test_checkpoint_commits.py FFFFF.                      [ 10%]
tests/integration/test_comprehensive_backup.py ..                        [ 11%]
tests/integration/test_e2e_backup_features.py ..F                        [ 13%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 17%]
tests/integration/test_update_annexed_files.py ..                        [ 18%]
tests/test_component_mode_bug.py ..                                      [ 20%]
tests/test_date_filtering.py .....                                       [ 22%]
tests/test_tsv_refactoring.py .....                                      [ 25%]
tests/unit/test_archive_discovery.py ........................            [ 40%]
tests/unit/test_atomic_file_write.py ..........                          [ 45%]
tests/unit/test_git_annex_metadata.py ......                             [ 49%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 52%]
tests/unit/test_hierarchical_video_paths.py .............                [ 60%]
tests/unit/test_new_video_detection.py ..                                [ 61%]
tests/unit/test_playlist_model.py ...                                    [ 63%]
tests/unit/test_quota_estimator.py .........                             [ 68%]
tests/unit/test_quota_manager.py .....................                   [ 81%]
tests/unit/test_video_model.py ...                                       [ 82%]
tests/unit/test_youtube_api_client.py ...................                [ 94%]
tests/unit/test_youtube_api_quota_handling.py ..........                 [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpir0nmkui/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpir0nmkui/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp0bzx37a_/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp0bzx37a_/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
______ TestCheckpointCommits.test_checkpoint_creates_intermediate_commits ______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f82c9d62fd0>

    def test_checkpoint_creates_intermediate_commits(self):
        """Test that checkpoints create commits at specified intervals."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Configure with small checkpoint interval (every 2 videos)
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service to return 5 videos
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    # Mock video objects
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Run backup
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + checkpoint(2) + checkpoint(4) + final(5)
>           assert len(commits) >= 4, f"Expected at least 4 commits, got {len(commits)}: {commits}"
E           AssertionError: Expected at least 4 commits, got 1: ['init']
E           assert 1 >= 4
E            +  where 1 = len(['init'])

tests/integration/test_checkpoint_commits.py:100: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmp0l6v3nsm/videos/videos.tsv'
_____ TestCheckpointCommits.test_checkpoint_disabled_creates_single_commit _____

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f82c9c28910>

    def test_checkpoint_disabled_creates_single_commit(self):
        """Test that disabling checkpoints creates only final commit."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Disable checkpoints
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_enabled=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + final backup (no checkpoints)
            checkpoint_commits = [c for c in commits if "Checkpoint:" in c]
            assert len(checkpoint_commits) == 0, f"Expected 0 checkpoints, got {checkpoint_commits}"
    
            # Should have final backup commit
            backup_commits = [c for c in commits if "Backup channel:" in c]
>           assert len(backup_commits) == 1, f"Expected 1 backup commit, got {backup_commits}"
E           AssertionError: Expected 1 backup commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:154: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpjdc_x48r/videos/videos.tsv'
____________ TestCheckpointCommits.test_checkpoint_regenerates_tsvs ____________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f82c9de9a70>

    def test_checkpoint_regenerates_tsvs(self):
        """Test that checkpoints regenerate TSV files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=4),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 5)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Spy on export.generate_all calls
                        original_generate = archiver.export.generate_all
                        generate_calls = []
    
                        def track_generate():
                            generate_calls.append(_count_metadata_files(repo_path))
                            return original_generate()
    
                        with patch.object(archiver.export, "generate_all", side_effect=track_generate):
                            archiver.backup_channel("test-channel")
    
            # Should have called generate_all at least twice (checkpoints)
>           assert len(generate_calls) >= 2, f"Expected at least 2 TSV generations, got {len(generate_calls)}"
E           AssertionError: Expected at least 2 TSV generations, got 1
E           assert 1 >= 2
E            +  where 1 = len([0])

tests/integration/test_checkpoint_commits.py:199: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmphlwbm_8f/videos/videos.tsv'
__________ TestCheckpointCommits.test_keyboard_interrupt_auto_commits __________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f82c9de90f0>

    def test_keyboard_interrupt_auto_commits(self):
        """Test that Ctrl+C triggers auto-commit of partial progress."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(
                    checkpoint_interval=10,  # Won't trigger during test
                    auto_commit_on_interrupt=True
                ),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    # Simulate Ctrl+C after processing 3 videos
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        # Should raise KeyboardInterrupt but auto-commit first
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have partial backup commit
            partial_commits = [c for c in commits if "Partial backup (interrupted)" in c]
>           assert len(partial_commits) == 1, f"Expected 1 partial commit, got {partial_commits}"
E           AssertionError: Expected 1 partial commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:257: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
______ TestCheckpointCommits.test_keyboard_interrupt_without_auto_commit _______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f82c9cd9370>

    def test_keyboard_interrupt_without_auto_commit(self):
        """Test that disabling auto-commit leaves changes uncommitted."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(auto_commit_on_interrupt=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history - should NOT have partial commit
            commits = _get_git_commit_messages(repo_path)
            partial_commits = [c for c in commits if "Partial backup" in c]
            assert len(partial_commits) == 0, f"Expected 0 partial commits, got {partial_commits}"
    
            # But should have uncommitted changes
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
>           assert result.stdout.strip() != "", "Should have uncommitted changes"
E           AssertionError: Should have uncommitted changes
E           assert '' != ''
E            +  where '' = <built-in method strip of str object at 0xa54f48>()
E            +    where <built-in method strip of str object at 0xa54f48> = ''.strip
E            +      where '' = CompletedProcess(args=['git', 'status', '--porcelain'], returncode=0, stdout='', stderr='').stdout

tests/integration/test_checkpoint_commits.py:317: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7f82c9de9cd0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpo7yhalyg', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpo7yhalyg', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp_hgvdt_f', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp_hgvdt_f', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpjuyd6co7', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpjuyd6co7', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_creates_intermediate_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_disabled_creates_single_commit
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_regenerates_tsvs
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_auto_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_without_auto_commit
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 10 failed, 158 passed, 2 skipped in 96.58s (0:01:36) =============
py313: exit 1 (97.58 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2146446
py313: FAIL âœ– in 1 minute 47.56 seconds
py314: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/40/annextube-0.2.1.post48+g40f233bdf.tar.gz
py314: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.14.2, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py314/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: timeout-2.4.0, cov-7.0.0, asyncio-1.3.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 170 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  7%]
tests/integration/test_checkpoint_commits.py FFFFF.                      [ 10%]
tests/integration/test_comprehensive_backup.py ..                        [ 11%]
tests/integration/test_e2e_backup_features.py ..F                        [ 13%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 17%]
tests/integration/test_update_annexed_files.py ..                        [ 18%]
tests/test_component_mode_bug.py ..                                      [ 20%]
tests/test_date_filtering.py .....                                       [ 22%]
tests/test_tsv_refactoring.py .....                                      [ 25%]
tests/unit/test_archive_discovery.py ........................            [ 40%]
tests/unit/test_atomic_file_write.py ..........                          [ 45%]
tests/unit/test_git_annex_metadata.py ......                             [ 49%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 52%]
tests/unit/test_hierarchical_video_paths.py .............                [ 60%]
tests/unit/test_new_video_detection.py ..                                [ 61%]
tests/unit/test_playlist_model.py ...                                    [ 63%]
tests/unit/test_quota_estimator.py .........                             [ 68%]
tests/unit/test_quota_manager.py .....................                   [ 81%]
tests/unit/test_video_model.py ...                                       [ 82%]
tests/unit/test_youtube_api_client.py ...................                [ 94%]
tests/unit/test_youtube_api_quota_handling.py ..........                 [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqqwntc8p/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqqwntc8p/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp4547tpuc/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp4547tpuc/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
______ TestCheckpointCommits.test_checkpoint_creates_intermediate_commits ______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f9955cf5310>

    def test_checkpoint_creates_intermediate_commits(self):
        """Test that checkpoints create commits at specified intervals."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Configure with small checkpoint interval (every 2 videos)
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service to return 5 videos
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    # Mock video objects
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Run backup
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + checkpoint(2) + checkpoint(4) + final(5)
>           assert len(commits) >= 4, f"Expected at least 4 commits, got {len(commits)}: {commits}"
E           AssertionError: Expected at least 4 commits, got 1: ['init']
E           assert 1 >= 4
E            +  where 1 = len(['init'])

tests/integration/test_checkpoint_commits.py:100: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmprhvlxyk_/videos/videos.tsv'
_____ TestCheckpointCommits.test_checkpoint_disabled_creates_single_commit _____

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f9955cf5d10>

    def test_checkpoint_disabled_creates_single_commit(self):
        """Test that disabling checkpoints creates only final commit."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            # Disable checkpoints
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(checkpoint_enabled=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            # Mock YouTube service
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have: init + final backup (no checkpoints)
            checkpoint_commits = [c for c in commits if "Checkpoint:" in c]
            assert len(checkpoint_commits) == 0, f"Expected 0 checkpoints, got {checkpoint_commits}"
    
            # Should have final backup commit
            backup_commits = [c for c in commits if "Backup channel:" in c]
>           assert len(backup_commits) == 1, f"Expected 1 backup commit, got {backup_commits}"
E           AssertionError: Expected 1 backup commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:154: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmpjihjtc1p/videos/videos.tsv'
____________ TestCheckpointCommits.test_checkpoint_regenerates_tsvs ____________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f9955c7ec40>

    def test_checkpoint_regenerates_tsvs(self):
        """Test that checkpoints regenerate TSV files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=4),
                backup=BackupConfig(checkpoint_interval=2, checkpoint_enabled=True),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 5)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    with patch.object(archiver, "_process_video", return_value=0):
                        # Spy on export.generate_all calls
                        original_generate = archiver.export.generate_all
                        generate_calls = []
    
                        def track_generate():
                            generate_calls.append(_count_metadata_files(repo_path))
                            return original_generate()
    
                        with patch.object(archiver.export, "generate_all", side_effect=track_generate):
                            archiver.backup_channel("test-channel")
    
            # Should have called generate_all at least twice (checkpoints)
>           assert len(generate_calls) >= 2, f"Expected at least 2 TSV generations, got {len(generate_calls)}"
E           AssertionError: Expected at least 2 TSV generations, got 1
E           assert 1 >= 2
E            +  where 1 = len([0])

tests/integration/test_checkpoint_commits.py:199: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.export:export.py:43 Videos directory does not exist, creating empty TSV
WARNING  annextube.services.archiver:archiver.py:783 Failed to generate TSV files: [Errno 2] No such file or directory: '/home/yoh/.tmp/tmp7v0vkuxz/videos/videos.tsv'
__________ TestCheckpointCommits.test_keyboard_interrupt_auto_commits __________

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f9955b11a70>

    def test_keyboard_interrupt_auto_commits(self):
        """Test that Ctrl+C triggers auto-commit of partial progress."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(
                    checkpoint_interval=10,  # Won't trigger during test
                    auto_commit_on_interrupt=True
                ),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    # Simulate Ctrl+C after processing 3 videos
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        # Should raise KeyboardInterrupt but auto-commit first
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history
            commits = _get_git_commit_messages(repo_path)
    
            # Should have partial backup commit
            partial_commits = [c for c in commits if "Partial backup (interrupted)" in c]
>           assert len(partial_commits) == 1, f"Expected 1 partial commit, got {partial_commits}"
E           AssertionError: Expected 1 partial commit, got []
E           assert 0 == 1
E            +  where 0 = len([])

tests/integration/test_checkpoint_commits.py:257: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
______ TestCheckpointCommits.test_keyboard_interrupt_without_auto_commit _______

self = <test_checkpoint_commits.TestCheckpointCommits object at 0x7f9955bf45f0>

    def test_keyboard_interrupt_without_auto_commit(self):
        """Test that disabling auto-commit leaves changes uncommitted."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
            _init_test_repo(repo_path)
    
            config = Config(
                sources=[SourceConfig(url="test-channel", type="channel")],
                components=ComponentsConfig(videos=False, metadata=True, captions=False),
                filters=FiltersConfig(limit=5),
                backup=BackupConfig(auto_commit_on_interrupt=False),
            )
    
            archiver = Archiver(repo_path, config)
    
            mock_videos = [
                {"id": f"video{i}", "title": f"Video {i}", "upload_date": "20260101"}
                for i in range(1, 6)
            ]
    
            with patch.object(archiver.youtube, "get_channel_videos", return_value=mock_videos):
                with patch.object(archiver.youtube, "metadata_to_video") as mock_to_video:
                    def create_mock_video(meta):
                        video = MagicMock()
                        video.video_id = meta["id"]
                        video.title = meta["title"]
                        video.upload_date = "2026-01-01"
                        return video
                    mock_to_video.side_effect = create_mock_video
    
                    process_count = [0]
    
                    def process_with_interrupt(video):
                        process_count[0] += 1
                        if process_count[0] == 3:
                            raise KeyboardInterrupt("User interrupted")
                        return 0
    
                    with patch.object(archiver, "_process_video", side_effect=process_with_interrupt):
                        with pytest.raises(KeyboardInterrupt):
                            archiver.backup_channel("test-channel")
    
            # Check commit history - should NOT have partial commit
            commits = _get_git_commit_messages(repo_path)
            partial_commits = [c for c in commits if "Partial backup" in c]
            assert len(partial_commits) == 0, f"Expected 0 partial commits, got {partial_commits}"
    
            # But should have uncommitted changes
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
>           assert result.stdout.strip() != "", "Should have uncommitted changes"
E           AssertionError: Should have uncommitted changes
E           assert '' != ''
E            +  where '' = <built-in method strip of str object at 0xad20f0>()
E            +    where <built-in method strip of str object at 0xad20f0> = ''.strip
E            +      where '' = CompletedProcess(args=['git', 'status', '--porcelain'], returncode=0, stdout='', stderr='').stdout

tests/integration/test_checkpoint_commits.py:317: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  annextube.services.archiver:archiver.py:733 Backup interrupted by user (Ctrl+C)
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7f9955b10fc0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpt6huz1_o', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpt6huz1_o', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpcheg34nr', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpcheg34nr', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpbpynodn9', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpbpynodn9', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_creates_intermediate_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_disabled_creates_single_commit
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_checkpoint_regenerates_tsvs
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_auto_commits
FAILED tests/integration/test_checkpoint_commits.py::TestCheckpointCommits::test_keyboard_interrupt_without_auto_commit
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============ 10 failed, 158 passed, 2 skipped in 102.39s (0:01:42) =============
py314: exit 1 (103.75 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2158067
py314: FAIL âœ– in 1 minute 58.2 seconds
lint: commands[0]> ruff check annextube/ tests/
UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> annextube/_version.py:15:5
   |
13 | TYPE_CHECKING = False
14 | if TYPE_CHECKING:
15 |     from typing import Tuple
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
16 |     from typing import Union
   |

I001 [*] Import block is un-sorted or un-formatted
  --> annextube/_version.py:15:5
   |
13 |   TYPE_CHECKING = False
14 |   if TYPE_CHECKING:
15 | /     from typing import Tuple
16 | |     from typing import Union
   | |____________________________^
17 |
18 |       VERSION_TUPLE = Tuple[Union[int, str], ...]
   |
help: Organize imports

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> annextube/_version.py:18:21
   |
16 |     from typing import Union
17 |
18 |     VERSION_TUPLE = Tuple[Union[int, str], ...]
   |                     ^^^^^
19 |     COMMIT_ID = Union[str, None]
20 | else:
   |
help: Replace with `tuple`

UP007 [*] Use `X | Y` for type annotations
  --> annextube/_version.py:18:27
   |
16 |     from typing import Union
17 |
18 |     VERSION_TUPLE = Tuple[Union[int, str], ...]
   |                           ^^^^^^^^^^^^^^^
19 |     COMMIT_ID = Union[str, None]
20 | else:
   |
help: Convert to `X | Y`

UP007 Use `X | Y` for type annotations
  --> annextube/_version.py:19:17
   |
18 |     VERSION_TUPLE = Tuple[Union[int, str], ...]
19 |     COMMIT_ID = Union[str, None]
   |                 ^^^^^^^^^^^^^^^^
20 | else:
21 |     VERSION_TUPLE = object
   |
help: Convert to `X | Y`

F401 [*] `annextube.models.channel.Channel` imported but unused
  --> annextube/cli/aggregate.py:10:38
   |
 9 | from annextube.lib.logging_config import get_logger
10 | from annextube.models.channel import Channel
   |                                      ^^^^^^^
11 |
12 | logger = get_logger(__name__)
   |
help: Remove unused import: `annextube.models.channel.Channel`

UP015 [*] Unnecessary mode argument
  --> annextube/cli/aggregate.py:70:31
   |
69 |     try:
70 |         with open(videos_tsv, 'r', encoding='utf-8') as f:
   |                               ^^^
71 |             reader = csv.DictReader(f, delimiter='\t')
72 |             rows = list(reader)
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> annextube/cli/aggregate.py:177:42
    |
175 |         try:
176 |             # Load channel.json
177 |             with open(channel_json_path, 'r', encoding='utf-8') as f:
    |                                          ^^^
178 |                 channel_data = json.load(f)
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
  --> annextube/cli/export.py:67:42
   |
65 |         for metadata_file in videos_dir.rglob("metadata.json"):
66 |             try:
67 |                 with open(metadata_file, 'r', encoding='utf-8') as f:
   |                                          ^^^
68 |                     video_data = json.load(f)
69 |                     channel_id = channel_id or video_data.get("channel_id", "")
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
  --> annextube/cli/export.py:87:35
   |
85 |     if videos_tsv.exists():
86 |         try:
87 |             with open(videos_tsv, 'r', encoding='utf-8') as f:
   |                                   ^^^
88 |                 reader = csv.DictReader(f, delimiter='\t')
89 |                 rows = list(reader)
   |
help: Remove mode argument

F841 Local variable `playlist_count` is assigned to but never used
   --> annextube/cli/export.py:116:9
    |
114 |     playlist_count = 0
115 |     if playlists_dir.exists():
116 |         playlist_count = len(list(playlists_dir.glob("*/playlist.json")))
    |         ^^^^^^^^^^^^^^
117 |
118 |     # Build channel.json
    |
help: Remove assignment to unused variable `playlist_count`

I001 [*] Import block is un-sorted or un-formatted
  --> annextube/lib/archive_discovery.py:7:1
   |
 5 |   """
 6 |
 7 | / from dataclasses import dataclass
 8 | | from pathlib import Path
 9 | | from typing import Literal
10 | |
11 | | from annextube.services.git_annex import GitAnnexService
   | |________________________________________________________^
   |
help: Organize imports

F401 [*] `annextube.lib.quota_manager.QuotaExceededError` imported but unused
  --> annextube/services/youtube_api.py:24:41
   |
23 | from annextube.lib.logging_config import get_logger
24 | from annextube.lib.quota_manager import QuotaExceededError, QuotaManager
   |                                         ^^^^^^^^^^^^^^^^^^
25 |
26 | logger = get_logger(__name__)
   |
help: Remove unused import: `annextube.lib.quota_manager.QuotaExceededError`

F541 [*] f-string without any placeholders
   --> tests/e2e/test_multi_channel.py:232:15
    |
230 |         print(f"Collection directory: {collection_dir}")
231 |         print("Structure:")
232 |         print(f"  - channels.tsv (2 channels)")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
233 |         print(f"  - ch-annextubetesting/ ({ch1_data['archive_stats']['total_videos_archived']} videos)")
234 |         print(f"  - ch-apopyk/ ({ch2_data['archive_stats']['total_videos_archived']} videos)")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/e2e/test_multi_channel.py:235:15
    |
233 |         print(f"  - ch-annextubetesting/ ({ch1_data['archive_stats']['total_videos_archived']} videos)")
234 |         print(f"  - ch-apopyk/ ({ch2_data['archive_stats']['total_videos_archived']} videos)")
235 |         print(f"  - web/index.html")
    |               ^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove extraneous `f` prefix

F401 [*] `json` imported but unused
 --> tests/integration/test_checkpoint_commits.py:3:8
  |
1 | """Integration tests for periodic checkpoint commits during backup."""
2 |
3 | import json
  |        ^^^^
4 | import subprocess
5 | import tempfile
  |
help: Remove unused import: `json`

F401 [*] `zoneinfo.ZoneInfo` imported but unused
 --> tests/unit/test_quota_manager.py:5:22
  |
3 | from datetime import datetime, timedelta, timezone
4 | from unittest.mock import MagicMock, patch
5 | from zoneinfo import ZoneInfo
  |                      ^^^^^^^^
6 |
7 | import pytest
  |
help: Remove unused import: `zoneinfo.ZoneInfo`

Found 17 errors.
[*] 14 fixable with the `--fix` option (1 hidden fix can be enabled with the `--unsafe-fixes` option).
lint: exit 1 (0.07 seconds) /home/yoh/proj/annextube> ruff check annextube/ tests/ pid=2169600
lint: FAIL âœ– in 0.08 seconds
type: commands[0]> mypy --ignore-missing-imports annextube/
annextube/models/channel.py:36: error: Incompatible types in assignment (expression has type "dict[Never, Never]", variable has type "ArchiveStats")  [assignment]
annextube/cli/aggregate.py:80: error: Value of type variable "SupportsRichComparisonT" of "min" cannot be "str | Any | None"  [type-var]
annextube/cli/aggregate.py:80: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/aggregate.py:81: error: Value of type variable "SupportsRichComparisonT" of "max" cannot be "str | Any | None"  [type-var]
annextube/cli/aggregate.py:81: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/aggregate.py:87: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/aggregate.py:87: note: Left operand is of type "int | None"
annextube/cli/aggregate.py:95: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/aggregate.py:95: note: Left operand is of type "int | None"
annextube/cli/export.py:96: error: Value of type variable "SupportsRichComparisonT" of "min" cannot be "str | Any | None"  [type-var]
annextube/cli/export.py:96: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/export.py:97: error: Value of type variable "SupportsRichComparisonT" of "max" cannot be "str | Any | None"  [type-var]
annextube/cli/export.py:97: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/export.py:101: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/export.py:101: note: Left operand is of type "int | None"
annextube/cli/export.py:106: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/export.py:106: note: Left operand is of type "int | None"
annextube/services/youtube_api.py:83: error: Need type annotation for "all_comments" (hint: "all_comments: list[<type>] = ...")  [var-annotated]
annextube/services/youtube.py:307: error: Need type annotation for "new_video_ids" (hint: "new_video_ids: list[<type>] = ...")  [var-annotated]
annextube/services/archiver.py:1263: error: If x = b'abc' then f"{x}" or "{}".format(x) produces "b'abc'", not "abc". If this is desired behavior, use f"{x!r}" or "{!r}".format(x). Otherwise, decode the bytes  [str-bytes-safe]
Found 16 errors in 6 files (checked 34 source files)
type: exit 1 (2.12 seconds) /home/yoh/proj/annextube> mypy --ignore-missing-imports annextube/ pid=2169649
type: FAIL âœ– in 2.16 seconds
e2e: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/41/annextube-0.2.1.post48+g40f233bdf.tar.gz
e2e: commands[0] /home/yoh/proj/annextube/frontend> npm install

up to date, audited 671 packages in 3s

137 packages are looking for funding
  run `npm fund` for details

8 moderate severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
e2e: commands[1] /home/yoh/proj/annextube/frontend> npm run build

> annextube-frontend@0.1.0 build
> vite build

vite v5.4.21 building for production...
transforming...
âœ“ 53 modules transformed.
rendering chunks...
computing gzip size...
../web/index.html                  0.49 kB â”‚ gzip:  0.31 kB
../web/assets/index-zXhaaQLs.css  18.13 kB â”‚ gzip:  3.51 kB
../web/assets/index-Fj-wER0D.js   85.42 kB â”‚ gzip: 27.44 kB
âœ“ built in 2.66s
e2e: commands[2] /home/yoh/proj/annextube/frontend> bash scripts/ensure-playwright-browsers.sh chromium
Checking if Playwright chromium is already installed...
FOUND: /home/yoh/.cache/ms-playwright/chromium-1208/chrome-linux64/chrome
Playwright chromium is already installed, skipping download.
e2e: commands[3] /home/yoh/proj/annextube/frontend> npm run test:e2e -- archive-workflow.spec.ts --project=archive-chromium

> annextube-frontend@0.1.0 test:e2e
> playwright test archive-workflow.spec.ts --project=archive-chromium


Error: Process from config.webServer was not able to start. Exit code: 1

[1A[2K
To open last HTML report run:

  npx playwright show-report

e2e: exit 1 (7.11 seconds) /home/yoh/proj/annextube/frontend> npm run test:e2e -- archive-workflow.spec.ts --project=archive-chromium pid=2170655
.pkg: _exit> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
  py310: FAIL code 1 (120.45=setup[28.67]+cmd[91.78] seconds)
  py311: FAIL code 1 (96.92=setup[9.06]+cmd[87.86] seconds)
  py312: FAIL code 1 (101.05=setup[9.57]+cmd[91.47] seconds)
  py313: FAIL code 1 (107.56=setup[9.98]+cmd[97.58] seconds)
  py314: FAIL code 1 (118.20=setup[14.45]+cmd[103.75] seconds)
  lint: FAIL code 1 (0.08=setup[0.01]+cmd[0.07] seconds)
  type: FAIL code 1 (2.16=setup[0.04]+cmd[2.12] seconds)
  e2e: FAIL code 1 (30.80=setup[13.74]+cmd[3.54,4.26,2.16,7.11] seconds)
  evaluation failed :( (577.35 seconds)
