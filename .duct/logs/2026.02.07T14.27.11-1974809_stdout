.pkg: _optional_hooks> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
.pkg: get_requires_for_build_sdist> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
.pkg: build_sdist> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
py310: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/30/annextube-0.2.1.post43+ge3f65865a.tar.gz
py310: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py310/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: cov-7.0.0, timeout-2.4.0, asyncio-1.3.0
asyncio: mode=strict, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 133 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  9%]
tests/integration/test_comprehensive_backup.py ..                        [ 10%]
tests/integration/test_e2e_backup_features.py ..F                        [ 12%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 18%]
tests/integration/test_update_annexed_files.py ..                        [ 19%]
tests/test_component_mode_bug.py ..                                      [ 21%]
tests/test_date_filtering.py .....                                       [ 24%]
tests/test_tsv_refactoring.py .....                                      [ 28%]
tests/unit/test_archive_discovery.py ........................            [ 46%]
tests/unit/test_atomic_file_write.py ..........                          [ 54%]
tests/unit/test_git_annex_metadata.py ......                             [ 58%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 63%]
tests/unit/test_hierarchical_video_paths.py .............                [ 72%]
tests/unit/test_new_video_detection.py ..                                [ 74%]
tests/unit/test_playlist_model.py ...                                    [ 76%]
tests/unit/test_quota_estimator.py .........                             [ 83%]
tests/unit/test_video_model.py ...                                       [ 85%]
tests/unit/test_youtube_api_client.py ...................                [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpxe5afcqk/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpxe5afcqk/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpig53pbwd/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpig53pbwd/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7f25b97425c0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpsqi0f5py', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpsqi0f5py', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpsbjz7v9x', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpsbjz7v9x', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp8ljpeboi', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py310/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py310/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py310/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp8ljpeboi', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.10.17-linux-x86_64-gnu/lib/python3.10/subprocess.py:526: CalledProcessError
=============================== warnings summary ===============================
.tox/py310/lib/python3.10/site-packages/google/api_core/_python_version_support.py:275
  /home/yoh/proj/annextube/.tox/py310/lib/python3.10/site-packages/google/api_core/_python_version_support.py:275: FutureWarning: You are using a Python version (3.10.17) which Google will stop supporting in new releases of google.api_core once it reaches its end of life (2026-10-04). Please upgrade to the latest Python version, or at least Python 3.11, to continue receiving updates for google.api_core past that date.
    warnings.warn(message, FutureWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
======== 5 failed, 126 passed, 2 skipped, 1 warning in 93.17s (0:01:33) ========
py310: exit 1 (93.99 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=1975468
py310: FAIL âœ– in 1 minute 50.5 seconds
py311: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/31/annextube-0.2.1.post43+ge3f65865a.tar.gz
py311: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.11.12, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py311/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: timeout-2.4.0, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 133 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  9%]
tests/integration/test_comprehensive_backup.py ..                        [ 10%]
tests/integration/test_e2e_backup_features.py ..F                        [ 12%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 18%]
tests/integration/test_update_annexed_files.py ..                        [ 19%]
tests/test_component_mode_bug.py ..                                      [ 21%]
tests/test_date_filtering.py .....                                       [ 24%]
tests/test_tsv_refactoring.py .....                                      [ 28%]
tests/unit/test_archive_discovery.py ........................            [ 46%]
tests/unit/test_atomic_file_write.py ..........                          [ 54%]
tests/unit/test_git_annex_metadata.py ......                             [ 58%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 63%]
tests/unit/test_hierarchical_video_paths.py .............                [ 72%]
tests/unit/test_new_video_detection.py ..                                [ 74%]
tests/unit/test_playlist_model.py ...                                    [ 76%]
tests/unit/test_quota_estimator.py .........                             [ 83%]
tests/unit/test_video_model.py ...                                       [ 85%]
tests/unit/test_youtube_api_client.py ...................                [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpmm02p1_v/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpmm02p1_v/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqs64ch0d/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqs64ch0d/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7faf3a6919d0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp73_t9rss', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp73_t9rss', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpv2_so56s', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpv2_so56s', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp8eqcqhyb', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py311/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py311/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py311/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp8eqcqhyb', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

../../.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/subprocess.py:571: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 5 failed, 126 passed, 2 skipped in 87.30s (0:01:27) ==============
py311: exit 1 (88.18 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=1986116
py311: FAIL âœ– in 1 minute 41.35 seconds
py312: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/32/annextube-0.2.1.post43+ge3f65865a.tar.gz
py312: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.12.12, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py312/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: asyncio-1.3.0, timeout-2.4.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 133 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  9%]
tests/integration/test_comprehensive_backup.py ..                        [ 10%]
tests/integration/test_e2e_backup_features.py ..F                        [ 12%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 18%]
tests/integration/test_update_annexed_files.py ..                        [ 19%]
tests/test_component_mode_bug.py ..                                      [ 21%]
tests/test_date_filtering.py .....                                       [ 24%]
tests/test_tsv_refactoring.py .....                                      [ 28%]
tests/unit/test_archive_discovery.py ........................            [ 46%]
tests/unit/test_atomic_file_write.py ..........                          [ 54%]
tests/unit/test_git_annex_metadata.py ......                             [ 58%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 63%]
tests/unit/test_hierarchical_video_paths.py .............                [ 72%]
tests/unit/test_new_video_detection.py ..                                [ 74%]
tests/unit/test_playlist_model.py ...                                    [ 76%]
tests/unit/test_quota_estimator.py .........                             [ 83%]
tests/unit/test_video_model.py ...                                       [ 85%]
tests/unit/test_youtube_api_client.py ...................                [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp65v92fav/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp65v92fav/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzkj3f9m8/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzkj3f9m8/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7faa31a269c0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmptekthe2n', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmptekthe2n', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqrk3n_2l', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpqrk3n_2l', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpdb9bl78r', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py312/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py312/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py312/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpdb9bl78r', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

.local/share/uv/python/cpython-3.12.12-linux-x86_64-gnu/lib/python3.12/subprocess.py:571: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 5 failed, 126 passed, 2 skipped in 93.09s (0:01:33) ==============
py312: exit 1 (93.92 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=1996738
py312: FAIL âœ– in 1 minute 46 seconds
py313: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/33/annextube-0.2.1.post43+ge3f65865a.tar.gz
py313: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.13.11, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py313/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: cov-7.0.0, asyncio-1.3.0, timeout-2.4.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 133 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  9%]
tests/integration/test_comprehensive_backup.py ..                        [ 10%]
tests/integration/test_e2e_backup_features.py ..F                        [ 12%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 18%]
tests/integration/test_update_annexed_files.py ..                        [ 19%]
tests/test_component_mode_bug.py ..                                      [ 21%]
tests/test_date_filtering.py .....                                       [ 24%]
tests/test_tsv_refactoring.py .....                                      [ 28%]
tests/unit/test_archive_discovery.py ........................            [ 46%]
tests/unit/test_atomic_file_write.py ..........                          [ 54%]
tests/unit/test_git_annex_metadata.py ......                             [ 58%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 63%]
tests/unit/test_hierarchical_video_paths.py .............                [ 72%]
tests/unit/test_new_video_detection.py ..                                [ 74%]
tests/unit/test_playlist_model.py ...                                    [ 76%]
tests/unit/test_quota_estimator.py .........                             [ 83%]
tests/unit/test_video_model.py ...                                       [ 85%]
tests/unit/test_youtube_api_client.py ...................                [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmprur2b3s2/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmprur2b3s2/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpcxezazxj/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpcxezazxj/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7f68eb73d220>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpfrpje0yi', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpfrpje0yi', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp8moqvwb2', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp8moqvwb2', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpai5y20jn', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py313/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py313/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py313/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpai5y20jn', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.13/subprocess.py:577: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 5 failed, 126 passed, 2 skipped in 101.65s (0:01:41) =============
py313: exit 1 (102.25 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2007552
py313: FAIL âœ– in 1 minute 58.36 seconds
py314: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/34/annextube-0.2.1.post43+ge3f65865a.tar.gz
py314: commands[0]> pytest --ignore=tests/e2e/test_web_ui.py tests/
============================= test session starts ==============================
platform linux -- Python 3.14.2, pytest-9.0.2, pluggy-1.6.0
cachedir: .tox/py314/.pytest_cache
rootdir: /home/yoh/proj/annextube
configfile: pyproject.toml
plugins: timeout-2.4.0, cov-7.0.0, asyncio-1.3.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 133 items

tests/e2e/test_multi_channel.py FF                                       [  1%]
tests/integration/test_api_enhanced_metadata.py .......ss.               [  9%]
tests/integration/test_comprehensive_backup.py ..                        [ 10%]
tests/integration/test_e2e_backup_features.py ..F                        [ 12%]
tests/integration/test_incremental_backup.py FF                          [ 14%]
tests/integration/test_new_video_components.py ..                        [ 15%]
tests/integration/test_no_timestamp_commits.py ...                       [ 18%]
tests/integration/test_update_annexed_files.py ..                        [ 19%]
tests/test_component_mode_bug.py ..                                      [ 21%]
tests/test_date_filtering.py .....                                       [ 24%]
tests/test_tsv_refactoring.py .....                                      [ 28%]
tests/unit/test_archive_discovery.py ........................            [ 46%]
tests/unit/test_atomic_file_write.py ..........                          [ 54%]
tests/unit/test_git_annex_metadata.py ......                             [ 58%]
tests/unit/test_git_annex_timestamp_filter.py ......                     [ 63%]
tests/unit/test_hierarchical_video_paths.py .............                [ 72%]
tests/unit/test_new_video_detection.py ..                                [ 74%]
tests/unit/test_playlist_model.py ...                                    [ 76%]
tests/unit/test_quota_estimator.py .........                             [ 83%]
tests/unit/test_video_model.py ...                                       [ 85%]
tests/unit/test_youtube_api_client.py ...................                [100%]

=================================== FAILURES ===================================
____________________ test_multi_channel_collection_workflow ____________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_multi_channel_collection_workflow():
        """Test complete multi-channel collection workflow.
    
        Creates a collection with two channels (AnnexTubeTesting and limited apopyk),
        aggregates metadata, and verifies web UI generation.
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Channel 1: AnnexTubeTesting (limit 3 videos)
            ch1_dir = collection_dir / "ch-annextubetesting"
            ch1_dir.mkdir()
    
            print("\n=== Creating channel 1: AnnexTubeTesting ===")
>           result = subprocess.run(
                [
                    sys.executable,
                    "-m",
                    "annextube",
                    "init",
                    str(ch1_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "3",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzgsapazo/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpzgsapazo/collection/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '3', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating channel 1: AnnexTubeTesting ===
__________________________ test_aggregate_with_depth ___________________________

    @pytest.mark.network
    @pytest.mark.ai_generated
    def test_aggregate_with_depth():
        """Test aggregate command with different depth levels."""
        with tempfile.TemporaryDirectory() as tmpdir:
            collection_dir = Path(tmpdir) / "collection"
            collection_dir.mkdir()
    
            # Create nested structure: org/channel/
            org_dir = collection_dir / "ukraine"
            org_dir.mkdir()
            ch_dir = org_dir / "ch-annextubetesting"
            ch_dir.mkdir()
    
            print("\n=== Creating nested channel ===")
>           result = subprocess.run(
                [
                    sys.executable, "-m", "annextube",
                    "init",
                    str(ch_dir),
                    "https://www.youtube.com/@AnnexTubeTesting",
                    "--limit",
                    "2",
                    "--comments",
                    "0",
                    "--no-captions",
                    "--no-thumbnails",
                ],
                capture_output=True,
                text=True,
                check=True,
            )

tests/e2e/test_multi_channel.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpbufcl3nt/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpbufcl3nt/collection/ukraine/ch-annextubetesting', 'https://www.youtube.com/@AnnexTubeTesting', '--limit', '2', '--comments', '0', '--no-captions', '--no-thumbnails']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
----------------------------- Captured stdout call -----------------------------

=== Creating nested channel ===
_ TestE2EBackupFeatures.test_default_init_includes_playlists_with_title_paths __

self = <test_e2e_backup_features.TestE2EBackupFeatures object at 0x7f92a116fce0>

    def test_default_init_includes_playlists_with_title_paths(self) -> None:
        """Test that default init config includes playlists and uses title-based paths."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Use annextube init with default settings (playlists=all, podcasts=all by default)
            # Using yarikoptic channel which has playlists
            channel_url = "https://www.youtube.com/@yarikoptic"
    
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), channel_url,
                 "--no-videos", "--comments", "0", "--no-captions", "--limit", "2"],
                check=True,
                capture_output=True
            )

tests/integration/test_e2e_backup_features.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpfksaym5m', 'https://www.youtube.com/@yarikoptic', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpfksaym5m', 'https://www.youtube.com/@yarikoptic', '--no-videos', '--comments', '0', '--no-captions', '--limit', '2']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
___________________ test_incremental_backup_no_reprocessing ____________________

    @pytest.mark.ai_generated
    def test_incremental_backup_no_reprocessing():
        """Test that running backup twice doesn't reprocess existing videos.
    
        This test verifies that the incremental update mode correctly identifies
        and skips already-downloaded videos, ensuring efficiency.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
        limit = 3  # Just 3 videos for fast testing
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           result = subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                capture_output=True,
                text=True,
                check=True
            )

tests/integration/test_incremental_backup.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp2473fw31', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = ''
stderr = "/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmp2473fw31', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
__________________ test_incremental_backup_detects_new_videos __________________

    @pytest.mark.ai_generated
    def test_incremental_backup_detects_new_videos():
        """Test that incremental backup correctly detects and fetches new videos.
    
        This test uses a larger limit on the second run to simulate new videos
        being available.
        """
        # Use the dedicated AnnexTube Test Channel (10 known videos)
        test_channel = "https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA"
    
        with tempfile.TemporaryDirectory() as tmpdir:
            repo_path = Path(tmpdir)
    
            # Initialize repository (disable playlists to test channel-only incremental behavior)
>           subprocess.run(
                [sys.executable, "-m", "annextube", "init", str(repo_path), test_channel,
                 "--no-videos", "--comments", "0", "--no-captions",
                 "--include-playlists", "none"],
                check=True,
                capture_output=True
            )

tests/integration/test_incremental_backup.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpalfe3soh', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', ...],)
kwargs = {'stderr': -1, 'stdout': -1}
process = <Popen: returncode: 1 args: ['/home/yoh/proj/annextube/.tox/py314/bin/python...>
stdout = b''
stderr = b"/home/yoh/proj/annextube/.tox/py314/bin/python3: No module named annextube.__main__; 'annextube' is a package and cannot be directly executed\n"
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout (seconds) is given and the process takes too long,
         a TimeoutExpired exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/yoh/proj/annextube/.tox/py314/bin/python3', '-m', 'annextube', 'init', '/home/yoh/.tmp/tmpalfe3soh', 'https://www.youtube.com/channel/UCHpuDwi3IorJ_Uez2e7pqHA', '--no-videos', '--comments', '0', '--no-captions', '--include-playlists', 'none']' returned non-zero exit status 1.

/usr/lib/python3.14/subprocess.py:577: CalledProcessError
=========================== short test summary info ============================
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:377: YOUTUBE_API_KEY not set - skipping real API test
SKIPPED [1] tests/integration/test_api_enhanced_metadata.py:407: YOUTUBE_API_KEY not set - skipping real API test
FAILED tests/e2e/test_multi_channel.py::test_multi_channel_collection_workflow
FAILED tests/e2e/test_multi_channel.py::test_aggregate_with_depth - subproces...
FAILED tests/integration/test_e2e_backup_features.py::TestE2EBackupFeatures::test_default_init_includes_playlists_with_title_paths
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_no_reprocessing
FAILED tests/integration/test_incremental_backup.py::test_incremental_backup_detects_new_videos
============= 5 failed, 126 passed, 2 skipped in 83.81s (0:01:23) ==============
py314: exit 1 (84.23 seconds) /home/yoh/proj/annextube> pytest --ignore=tests/e2e/test_web_ui.py tests/ pid=2019056
py314: FAIL âœ– in 1 minute 37.23 seconds
lint: commands[0]> ruff check annextube/ tests/
F401 [*] `annextube.models.channel.Channel` imported but unused
  --> annextube/cli/aggregate.py:10:38
   |
 9 | from annextube.lib.logging_config import get_logger
10 | from annextube.models.channel import Channel
   |                                      ^^^^^^^
11 |
12 | logger = get_logger(__name__)
   |
help: Remove unused import: `annextube.models.channel.Channel`

UP015 [*] Unnecessary mode argument
  --> annextube/cli/aggregate.py:70:31
   |
69 |     try:
70 |         with open(videos_tsv, 'r', encoding='utf-8') as f:
   |                               ^^^
71 |             reader = csv.DictReader(f, delimiter='\t')
72 |             rows = list(reader)
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> annextube/cli/aggregate.py:177:42
    |
175 |         try:
176 |             # Load channel.json
177 |             with open(channel_json_path, 'r', encoding='utf-8') as f:
    |                                          ^^^
178 |                 channel_data = json.load(f)
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
  --> annextube/cli/export.py:67:42
   |
65 |         for metadata_file in videos_dir.rglob("metadata.json"):
66 |             try:
67 |                 with open(metadata_file, 'r', encoding='utf-8') as f:
   |                                          ^^^
68 |                     video_data = json.load(f)
69 |                     channel_id = channel_id or video_data.get("channel_id", "")
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
  --> annextube/cli/export.py:87:35
   |
85 |     if videos_tsv.exists():
86 |         try:
87 |             with open(videos_tsv, 'r', encoding='utf-8') as f:
   |                                   ^^^
88 |                 reader = csv.DictReader(f, delimiter='\t')
89 |                 rows = list(reader)
   |
help: Remove mode argument

F841 Local variable `playlist_count` is assigned to but never used
   --> annextube/cli/export.py:116:9
    |
114 |     playlist_count = 0
115 |     if playlists_dir.exists():
116 |         playlist_count = len(list(playlists_dir.glob("*/playlist.json")))
    |         ^^^^^^^^^^^^^^
117 |
118 |     # Build channel.json
    |
help: Remove assignment to unused variable `playlist_count`

I001 [*] Import block is un-sorted or un-formatted
  --> annextube/lib/archive_discovery.py:7:1
   |
 5 |   """
 6 |
 7 | / from dataclasses import dataclass
 8 | | from pathlib import Path
 9 | | from typing import Literal
10 | |
11 | | from annextube.services.git_annex import GitAnnexService
   | |________________________________________________________^
   |
help: Organize imports

F541 [*] f-string without any placeholders
   --> tests/e2e/test_multi_channel.py:232:15
    |
230 |         print(f"Collection directory: {collection_dir}")
231 |         print("Structure:")
232 |         print(f"  - channels.tsv (2 channels)")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
233 |         print(f"  - ch-annextubetesting/ ({ch1_data['archive_stats']['total_videos_archived']} videos)")
234 |         print(f"  - ch-apopyk/ ({ch2_data['archive_stats']['total_videos_archived']} videos)")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/e2e/test_multi_channel.py:235:15
    |
233 |         print(f"  - ch-annextubetesting/ ({ch1_data['archive_stats']['total_videos_archived']} videos)")
234 |         print(f"  - ch-apopyk/ ({ch2_data['archive_stats']['total_videos_archived']} videos)")
235 |         print(f"  - web/index.html")
    |               ^^^^^^^^^^^^^^^^^^^^^
    |
help: Remove extraneous `f` prefix

Found 9 errors.
[*] 8 fixable with the `--fix` option (1 hidden fix can be enabled with the `--unsafe-fixes` option).
lint: exit 1 (0.01 seconds) /home/yoh/proj/annextube> ruff check annextube/ tests/ pid=2029194
lint: FAIL âœ– in 0.02 seconds
type: commands[0]> mypy --ignore-missing-imports annextube/
annextube/models/channel.py:36: error: Incompatible types in assignment (expression has type "dict[Never, Never]", variable has type "ArchiveStats")  [assignment]
annextube/services/youtube_api.py:80: error: Need type annotation for "all_comments" (hint: "all_comments: list[<type>] = ...")  [var-annotated]
annextube/cli/aggregate.py:80: error: Value of type variable "SupportsRichComparisonT" of "min" cannot be "str | Any | None"  [type-var]
annextube/cli/aggregate.py:80: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/aggregate.py:81: error: Value of type variable "SupportsRichComparisonT" of "max" cannot be "str | Any | None"  [type-var]
annextube/cli/aggregate.py:81: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/aggregate.py:87: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/aggregate.py:87: note: Left operand is of type "int | None"
annextube/cli/aggregate.py:95: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/aggregate.py:95: note: Left operand is of type "int | None"
annextube/services/youtube.py:307: error: Need type annotation for "new_video_ids" (hint: "new_video_ids: list[<type>] = ...")  [var-annotated]
annextube/services/archiver.py:1161: error: If x = b'abc' then f"{x}" or "{}".format(x) produces "b'abc'", not "abc". If this is desired behavior, use f"{x!r}" or "{!r}".format(x). Otherwise, decode the bytes  [str-bytes-safe]
annextube/cli/export.py:96: error: Value of type variable "SupportsRichComparisonT" of "min" cannot be "str | Any | None"  [type-var]
annextube/cli/export.py:96: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/export.py:97: error: Value of type variable "SupportsRichComparisonT" of "max" cannot be "str | Any | None"  [type-var]
annextube/cli/export.py:97: error: Incompatible types in assignment (expression has type "str | Any | None", target has type "int | None")  [assignment]
annextube/cli/export.py:101: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/export.py:101: note: Left operand is of type "int | None"
annextube/cli/export.py:106: error: Unsupported operand types for + ("None" and "int")  [operator]
annextube/cli/export.py:106: note: Left operand is of type "int | None"
Found 16 errors in 6 files (checked 33 source files)
type: exit 1 (0.14 seconds) /home/yoh/proj/annextube> mypy --ignore-missing-imports annextube/ pid=2029235
type: FAIL âœ– in 0.15 seconds
e2e: install_package> .venv/bin/uv pip install --reinstall --no-deps annextube@/home/yoh/proj/annextube/.tox/.tmp/package/35/annextube-0.2.1.post43+ge3f65865a.tar.gz
e2e: commands[0] /home/yoh/proj/annextube/frontend> npm install

up to date, audited 671 packages in 1s

137 packages are looking for funding
  run `npm fund` for details

8 moderate severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
e2e: commands[1] /home/yoh/proj/annextube/frontend> npm run build

> annextube-frontend@0.1.0 build
> vite build

vite v5.4.21 building for production...
transforming...
âœ“ 53 modules transformed.
rendering chunks...
computing gzip size...
../web/index.html                  0.49 kB â”‚ gzip:  0.31 kB
../web/assets/index-zXhaaQLs.css  18.13 kB â”‚ gzip:  3.51 kB
../web/assets/index-Fj-wER0D.js   85.42 kB â”‚ gzip: 27.44 kB
âœ“ built in 1.61s
e2e: commands[2] /home/yoh/proj/annextube/frontend> bash scripts/ensure-playwright-browsers.sh chromium
Checking if Playwright chromium is already installed...
FOUND: /home/yoh/.cache/ms-playwright/chromium-1208/chrome-linux64/chrome
Playwright chromium is already installed, skipping download.
e2e: commands[3] /home/yoh/proj/annextube/frontend> npm run test:e2e -- archive-workflow.spec.ts --project=archive-chromium

> annextube-frontend@0.1.0 test:e2e
> playwright test archive-workflow.spec.ts --project=archive-chromium


Error: Process from config.webServer was not able to start. Exit code: 1

[1A[2K
To open last HTML report run:

  npx playwright show-report

e2e: exit 1 (4.77 seconds) /home/yoh/proj/annextube/frontend> npm run test:e2e -- archive-workflow.spec.ts --project=archive-chromium pid=2029840
.pkg: _exit> python /home/yoh/proj/annextube/.venv/lib/python3.12/site-packages/pyproject_api/_backend.py True hatchling.build
  py310: FAIL code 1 (110.50=setup[16.52]+cmd[93.99] seconds)
  py311: FAIL code 1 (101.35=setup[13.17]+cmd[88.18] seconds)
  py312: FAIL code 1 (106.00=setup[12.08]+cmd[93.92] seconds)
  py313: FAIL code 1 (118.35=setup[16.10]+cmd[102.25] seconds)
  py314: FAIL code 1 (97.23=setup[13.00]+cmd[84.23] seconds)
  lint: FAIL code 1 (0.02=setup[0.00]+cmd[0.01] seconds)
  type: FAIL code 1 (0.15=setup[0.00]+cmd[0.14] seconds)
  e2e: FAIL code 1 (18.22=setup[9.07]+cmd[1.51,2.51,0.37,4.77] seconds)
  evaluation failed :( (551.85 seconds)
